║ ( 0,  1) 	( 0, -1)
═ ( 1,  0) 	(-1,  0)
╔ ( 1.  0) 	( 0, -1)
╗ (-1,  0) 	( 0,  1)
╚ ( 1,  0) 	( 0, -1)
╝ (-1,  0)	( 0, -1)
╦ ( 1,  0) 	(-1,  0)	( 0,  1)
╠ ( 1,  0) 	( 0,  1)	( 0, -1)
╣ (-1,  0)	( 0,  1)	( 0, -1)
╩ ( 1,  0)	(-1,  0)	( 0, -1)
╬ ( 1,  0)	(-1,  0)	( 0,  1)	( 0, -1)

向右下為正

Ex:
   0 1 2 3 4 5 6
   
0  0 0 0 0 0 0 0
1  0 @ 2 2 2 4 0
2  0 0 3 2 2 6 0
3  0 0 1 0 0 0 0
4  0 0 1 0 0 0 0
5  0 0 5 2 2 # 0 
6  0 0 0 0 0 0 0

declare.
int step[][] = {(1, 0), (-1, 0), (0, 1), (0, -1)};
	step[0] > 向右走
	step[1] > 向左走
	step[2] > 向下走
	step[3] > 向上走
	step[N][0] > 水平位移
	step[N][1] > 垂直位移

init.
此關預設起點水管向右灌
int nextStep = 0;
起始座標(nowX, nowY) = (1, 1);

Step 1.
  nextX = nowX + step[nextStep][0];
  nextY = nowY + step[nextStep][1];
  得到(nextX, nextY) = (2, 1);
  map[nextX][nextY] = 2; // 形狀為═
  接下來可能的位移為( 1,  0), (-1,  0)兩種
  因為(nextX + -1, nextY + 0) == (nowX, nowY)
  所以下一步為(nextX + 1, nextY + 0)
